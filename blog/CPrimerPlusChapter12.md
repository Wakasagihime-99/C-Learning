<!--
 * @Date: 2023-03-06
 * @LastEditors: Wakasagihime
 * @LastEditTime: 2023-03-15
 * @FilePath: \\C_Projectd:\\code\\c\\blog\\CPrimerPlusChapter12.md
 * @Description: 
-->
# C Primer Plus Chapter 12

存储类别、链接和内存管理

## 存储类别

1. 对象

    目前所使用的编程示例数据都存储在内存中，从硬件方面看，被存储的每个值都占用一定的物理内存，C语言把这样的一块内存称为**对象**(object)。对象可以存储一个或多个值，可能并未存储实际的值，但它在存储适当的值时一定具有相应的大小；从软件方面看，程序需要一种方法访问对象，这可以通过声明变量来完成。

    变量名不是指定对象的唯一途径。如：

    ```c
    int entity = 3;
    int *pt = &entity;
    int ranks[10];
    ```

    行1创建了名为entity的**标识符**(indentifier)标识符是一个名称，可用来**指定**(designate)特定对象的内容。

    而行2中，pt是一个标识符，指定了一个存储地址的对象。*pt不是标识符，是**表达式**，同时也是是**左值**（内存中有具体位置的对象），可以被赋值。entity既是标识符也是左值。

    ranks声明创建了一个可容纳10个int类型元素的对象，该数组每个元素也是一个对象。ranks + 2 *entity既不是标识符，也不是左值。但\*(ranks + 2 \* entity)是左值。

    ```c
    const char *pc = "Behold a string literal!";
    ```

    pc是一个可修改的左值，而*pc是不可修改的左值。字符串这个数组是一个对象，每个字符也是一个对象。字符串字面量是不可修改的左值。

    可以用**存储期**(storage duration)描述对象，可以用**作用域**(scope)和**链接**(linkage)描述标识符，标识符的作用域和链接表明了程序哪些部分可以使用它。标识符可以在源代码的多文件中共享、也可以只在特定文件特定函数的某部分中。对象可存在于程序的执行期，也可仅存在于它所在函数的执行期。可以通过函数调用的方式显示分配和释放内存。

2. 作用域

    一个C变量的作用域可以是块作用域、函数作用域、函数原型作用域和文件作用域。在某一作用域使用变量或函数前，必须在该作用域下声明该变量或函数。

    定义在块中的变量具有**块作用域**(block scope)。在函数声明中定义的形参虽然在花括号之前，但也是具有块作用域的。

    **函数作用域**(function scope)仅对goto的标签有用，标签(label)可以被定义在函数的任何位置，与内外层、在使用前定义还是使用后定义无关，在函数内定义即可被使用。

    **函数原型作用域**(function prototype scope)即声明函数原型时，里面形参的作用域只有声明的这一行。所以可以省略形参变量的名字（除了变长数组），也可以在函数定义时形参换一个名字。

    **文件作用域**(file scope)即在函数之外定义的变量，也叫全局变量(global variable)。翻译单元简单来讲是.c及其直接间接的头文件构成的整个文件，文件作用域实际上是整个翻译单元都可见。

3. 链接

    C变量有3种链接属性：外部链接、内部链接或无链接。只有文件作用域可以是不同链接。外部链接变量可以在多个文件中使用，内部链接变量只能在一个翻译单元中使用。

    不使用static修饰符的为文件作用域、外部链接变量（其他文件可引用），使用static则为内部链接变量。（函数也可使用static保证只有本文件可使用）。

4. 存储期

    作用域和链接描述了标识符的可见性。存储期描述了这些标识符访问的对象的生存期。C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。

    若对象具有静态存储期，则它在程序执行期间一直存在。文件作用域变量具有静态存储期，此时static表明的是其链接属性而不是存储期。块作用域变量使用static关键字也会变为拥有静态存储期（不是说变量在块外也可以访问，而是可以用指针等访问其存储地址）。

    线程存储期用于并发程序设计。（感觉C不怎么用，C++再说）。

    块作用域的变量通常拥有自动存储期，即定义时分配一个栈，块结束后销毁。

    动态存储期就是用new或者malloc分配的内存，如果不主动释放，在整个程序都占有内存。

    ![存储类别的存储期与作用域](./picture/%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB.png "存储类别表")

5. 自动变量与寄存器变量

    属于自动存储类别的变量具有自动存储期、块作用域且无链接。外层定义的变量在内层有效。若内外层变量同名，则隐藏外层，优先内层。退出内层后，将回归外层。（请别同名）。自动变量要初始化。

    使用register关键字声明，但是结果不一定的确使用了寄存器（最快可用内存），因编译器可能忽略你的请求。

6. 块作用域的静态变量

    ```c
    void trystat(void)
    {
        int fade = 1;
        static int stay = 1;

        printf("fade = %d and stay = %d\n", fade++, stay++)
    }
    ```

    在该例中，stay只会被初始化一次，如果未显示初始化static变量则自动初始化为0。实际上，该条声明并不是调用该函数时才初始化，因为静态变量和外部变量在程序被载入时已执行完毕。在此处定义只是表示只有trystat()函数可见此变量。不允许在形参中使用static。

7. 外部链接的静态变量

    引用其他文件变量需用extern关键字。int a =1;此为**定义式声明**(defining declaration),而extern int a;是**引用式声明**(referencing declaratin),且不可再初始化。

    外部变量不被显式初始化将自动初始化为0，尤其是外部定义的数组元素。但是与其他自动变量的区别是，他们只能使用常量表达式初始化（sizeof(int)这种也是常量表达式），如下情况是不允许的。

    ```c
    int x = 10;
    int x2 = 2 * x;
    ```

## 随机函数和静态变量

讲了一些伪随机数的东西，time()、rand()的使用。

## 掷骰子

## 分配内存：malloc()和free()

1. malloc()和free()

    malloc()接收一个参数，即所需内存字节数。返回该内存的首地址，一般将其返回给void型指针。若分配内存失败则返回空指针。用法示例如下：

    ```c
    double * ptd;
    ptd = (double *) malloc(30 * sizeof(double));
    ```

    C中不一定要强制转换为double，但是C++中用。

    malloc()与free()搭配使用，其原型都定义在stdlib.h头文件中。free()接收一个参数，即malloc分配的地址。不能用free释放通过其他方式分配的内存。一定要在使用完成后free，否则可能耗尽所有内存，这类问题被称为内存泄漏。

    exit()同样定义在stdlib.h头文件中，exit(EXIT_FAILURE)为非正常运行导致退出程序。exit(EXIT_SUCCESS)为正常运行并退出程序，相当于return 0;EXIT_FAILURE为1，EXIT_SUCCESS为0，同样定义在stdlib.h中。

2. calloc()

    calloc()接收两个无符号整数作为参数，第一个参数是所需存储单元的数量，第二个参数是存储单元的大小。calloc把块中所有位都设置为0。可被free释放。其典型用法如下：

    ```c
    long * newmem;
    newmem= (long *) calloc(100, sizeof(long));
    ```

3. 变长数组

    malloc创建多维变长数组语法较为繁琐：

    ```c
    int n = 5, m = 6;
    int (* p)[m];
    p = (int (*)[m]) malloc(n * m * sizeof(int));
    ```

    程序把静态对象、自动对象和动态分配对象存储在不同区域，一般而言，动态分配对象比栈对象（自动对象）慢。

## ANSI C类型限定符

### const

如const等限定符，用重了自动忽略其他的（限定符是幂等的），如const const const int a;即为const a;

对全局数据应使用const关键字。可使用两种方法：

- 在各文件前定义const数据，其他文件使用extern进行引用。(如果不用const，数据可能会被别的文件、函数所改变！)。

- 可以在某头文件种定义const数据，并让其他引用此头文件。记住：你必须使用static声明全局const变量，因若不适用const，则若多个文件都包含了此头文件，则多个文件中都有一个标识符相同的定义式声明，C标准不允许。

- 故此，不要在头文件中声明可以变动的变量。不要用头文件声明变量和其他文件通信。

- 头文件方法的好处是较为方便，但因每个都是单独的数据副本，若声明的是大数组，则不太好。

### volatile

volatile限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址及在其他程序或同时运行的线程中共享数据。语法与const一样。

```c
volatile int locl;    //locl是一个易变的位置
volatile int * ploc； //ploc是一个指向易变位置的指针
```

volatile的目的是为了阻止部分编译器优化。在一个变量值被多次使用时，编译器有可能将其临时存储到寄存器中，并从寄存器中读取值以节约时间，这个过程被称为高速缓存。但若有其他代理改变了变量的值，编译器不从原始位置读数将导致错误，故声明volatile可防止此情况。

const和volatile可同时使用，通常用于硬件时钟等不能程序改变，可代理改变的变量。如：

```c
volatile const int loc;
const volatile int * ploc;
```

### restrict

restrict关键字允许编译器优化某部分代码以便更好的支持计算。只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。例如：

```c
int * restrict restar = (int *) malloc(10 * sizeof(int));
int ar[10];
int * par = ar;
```

par既不是访问ar初始方式，也不是唯一方式。而restar则为restrict形式。

```c
for (n = 0; n < 10; n ++)
{
    par[n] += 5;
    restar[n] += 5;
    ar[n] *= 2;
    par[n] += 3;
    restar[n] += 3;
}
```

因为restar为严格形式，则编译器可以将两条分开的语句优化为：restar[n] += 8;而若是把ar数组进行优化，则会产生问题。不适用restrict都将默认不优化。

例如memcpy函数的原型：

```c
void * memcpy(void * restrict s1, const void * restrict s2, size_t n);
```

restrict限定符使两地址不允许重复。

### _Atomic类型限定符

是关于线程的，暂不了解。

### C99的新特性

C99允许：

```c
void ofmouth(int a1[const], int a2[restrict], int n);
```

和const/restrict指针相同。

此外，增加了static的新用法：

```c
double stick(double ar[static 20]);
```

即：传递的是指针，但指针指向的是一个数组，且数组内含20个元素。
